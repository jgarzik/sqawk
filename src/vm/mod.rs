//! SQL Virtual Machine (VM) bytecode execution engine
//!
//! This module implements a bytecode-based SQL execution engine inspired by SQLite's architecture.
//! The engine operates in two phases:
//! 1. Compile SQL statements into bytecode instructions
//! 2. Execute bytecode instructions in a virtual machine (VM)
//!
//! For more information on this approach, see: https://www.sqlite.org/opcode.html

pub mod bytecode;
pub mod compiler;
pub mod engine;

use crate::error::{SqawkError, SqawkResult};
use crate::database::Database;
use crate::table::Table;

/// Execute SQL using the VM execution engine
///
/// This is the main entry point for VM-based SQL execution in Sqawk.
/// It implements a two-phase approach:
/// 1. SQL parsing and bytecode generation
/// 2. VM execution of bytecode instructions
pub fn execute_vm(
    sql: &str, 
    database: &Database,
    verbose: bool
) -> SqawkResult<Option<Table>> {
    if verbose {
        println!("VM Engine: Executing SQL via bytecode: {}", sql);
    }

    // Phase 1: Compile SQL to bytecode
    let mut compiler = compiler::SqlCompiler::new(database, verbose);
    let program = compiler.compile(sql)?;
    
    if verbose {
        println!("Generated bytecode:");
        println!("{}", program);
    }
    
    // Phase 2: Execute bytecode in VM engine
    let mut vm = engine::VmEngine::new(database, verbose);
    vm.init(program);
    
    // Execute the bytecode program
    vm.execute()?;
    
    // Return the result table from execution
    vm.create_result_table()
}