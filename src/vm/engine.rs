//! SQL VM engine that executes bytecode instructions
//!
//! This module implements the virtual machine that executes bytecode instructions
//! generated by the compiler. It maintains internal state like registers, cursors,
//! and the program counter during execution.

use std::collections::HashMap;
use crate::database::Database;
use crate::error::{SqawkError, SqawkResult};
use crate::table::{Table, Value};
use super::bytecode::{Instruction, OpCode, Program, Register};

/// Table cursor for VM execution
struct Cursor {
    /// The table being accessed
    table: Table,
    /// Current row position (0-based)
    position: usize,
    /// Whether the cursor is at a valid row
    valid: bool,
}

impl Cursor {
    /// Create a new cursor for a table
    fn new(table: Table) -> Self {
        Self {
            table,
            position: 0,
            valid: false,
        }
    }
    
    /// Move to the first row
    fn rewind(&mut self) -> bool {
        self.position = 0;
        self.valid = self.position < self.table.row_count();
        self.valid
    }
    
    /// Move to the next row
    fn next(&mut self) -> bool {
        if !self.valid {
            return false;
        }
        
        self.position += 1;
        self.valid = self.position < self.table.row_count();
        self.valid
    }
    
    /// Get a column value at the current position
    fn column(&self, idx: usize) -> Option<Value> {
        if !self.valid || idx >= self.table.column_count() {
            return None;
        }
        
        // Access rows from the table using the rows() method
        let rows = self.table.rows();
        if self.position < rows.len() {
            rows[self.position].get(idx).cloned()
        } else {
            None
        }
    }
}

/// SQL VM engine that executes bytecode
pub struct VmEngine<'a> {
    /// The database containing tables
    database: &'a Database,
    
    /// The program being executed
    program: Program,
    
    /// Program counter (current instruction address)
    pc: usize,
    
    /// VM registers
    registers: Vec<Register>,
    
    /// Table cursors
    cursors: HashMap<usize, Cursor>,
    
    /// Result rows from SELECT statements
    results: Vec<Vec<Value>>,
    
    // Removed unused fields for column_names, modified_tables, and affected_rows
    
    /// Whether the engine is in verbose mode
    verbose: bool,
}

impl<'a> VmEngine<'a> {
    /// Create a new VM engine
    pub fn new(database: &'a Database, verbose: bool) -> Self {
        Self {
            database,
            program: Program::new(),
            pc: 0,
            registers: Vec::new(),
            cursors: HashMap::new(),
            results: Vec::new(),
            verbose,
        }
    }
    
    /// Initialize the VM with a program to execute
    pub fn init(&mut self, program: Program) {
        self.program = program;
        self.pc = 0;
        self.registers = Vec::new();
        self.cursors.clear();
        self.results.clear();
        
        // Allocate enough registers for the program
        let max_reg = self.program.instructions.iter()
            .map(|i| i.p1.max(i.p2).max(i.p3))
            .max()
            .unwrap_or(10);
        
        // Allocate a few extra registers just in case
        self.registers = vec![Register::Null; (max_reg + 5) as usize];
        
        if self.verbose {
            println!("VM initialized with program:\n{}", self.program);
        }
    }
    
    /// Execute the current program
    pub fn execute(&mut self) -> SqawkResult<()> {
        if self.program.is_empty() {
            return Err(SqawkError::VmError("No program to execute".to_string()));
        }
        
        // Start execution at PC 0
        self.pc = 0;
        
        // Main execution loop
        loop {
            // Get current instruction
            let inst_clone = self.program.get(self.pc)
                .ok_or_else(|| SqawkError::VmError(
                    format!("Invalid program counter: {}", self.pc)
                ))?
                .clone(); // Clone the instruction to avoid borrowing issues
            
            if self.verbose {
                println!("Executing [{}]: {}", self.pc, inst_clone);
            }
            
            // Execute the instruction
            match self.execute_instruction(&inst_clone)? {
                ExecuteResult::Continue => {
                    // Move to next instruction
                    self.pc += 1;
                },
                ExecuteResult::Jump(addr) => {
                    // Jump to specified address
                    self.pc = addr;
                },
                ExecuteResult::Halt => {
                    // End execution
                    break;
                }
            }
        }
        
        Ok(())
    }
    
    /// Execute a single instruction
    fn execute_instruction(&mut self, inst: &Instruction) -> SqawkResult<ExecuteResult> {
        match inst.opcode {
            OpCode::Init => {
                // Initialize VM and jump to start address in P2
                Ok(ExecuteResult::Jump(inst.p2 as usize))
            },
            
            OpCode::Goto => {
                // Unconditional jump to address in P2
                Ok(ExecuteResult::Jump(inst.p2 as usize))
            },
            
            OpCode::Halt => {
                // End execution
                Ok(ExecuteResult::Halt)
            },
            
            OpCode::OpenRead => {
                // Open a cursor for reading a table
                let cursor_idx = inst.p1 as usize;
                let table_name = inst.p4.clone().unwrap_or_default();
                
                // Check if the table exists
                if !self.database.has_table(&table_name) {
                    return Err(SqawkError::TableNotFound(table_name));
                }
                
                // Get the table from the database (safe to unwrap since we checked it exists)
                let table = self.database.get_table(&table_name).unwrap();
                
                // Create a cursor for the table
                let cursor = Cursor::new(table.clone());
                self.cursors.insert(cursor_idx, cursor);
                
                Ok(ExecuteResult::Continue)
            },
            
            OpCode::OpenWrite => {
                // Not implementing write operations for the MVP
                Err(SqawkError::UnsupportedSqlFeature("Write operations not supported in VM".to_string()))
            },
            
            OpCode::Close => {
                // Close a cursor
                let cursor_idx = inst.p1 as usize;
                self.cursors.remove(&cursor_idx);
                
                Ok(ExecuteResult::Continue)
            },
            
            OpCode::Rewind => {
                // Rewind a cursor to the first row
                let cursor_idx = inst.p1 as usize;
                let jump_addr = inst.p2 as usize;
                
                if let Some(cursor) = self.cursors.get_mut(&cursor_idx) {
                    if cursor.rewind() {
                        // Found at least one row
                        Ok(ExecuteResult::Continue)
                    } else {
                        // Empty table, jump
                        Ok(ExecuteResult::Jump(jump_addr))
                    }
                } else {
                    Err(SqawkError::VmError(format!("Invalid cursor: {}", cursor_idx)))
                }
            },
            
            OpCode::Next => {
                // Move cursor to next row
                let cursor_idx = inst.p1 as usize;
                let jump_addr = inst.p2 as usize;
                
                if let Some(cursor) = self.cursors.get_mut(&cursor_idx) {
                    if cursor.next() {
                        // More rows to process
                        Ok(ExecuteResult::Jump(jump_addr))
                    } else {
                        // No more rows
                        Ok(ExecuteResult::Continue)
                    }
                } else {
                    Err(SqawkError::VmError(format!("Invalid cursor: {}", cursor_idx)))
                }
            },
            
            OpCode::Column => {
                // Read a column value into a register
                let cursor_idx = inst.p1 as usize;
                let column_idx = inst.p2 as usize;
                let register_idx = inst.p3 as usize;
                
                if let Some(cursor) = self.cursors.get(&cursor_idx) {
                    if let Some(value) = cursor.column(column_idx) {
                        // Store the value in the register
                        if register_idx < self.registers.len() {
                            self.registers[register_idx] = Register::from(value);
                            Ok(ExecuteResult::Continue)
                        } else {
                            Err(SqawkError::VmError(format!("Register index out of bounds: {}", register_idx)))
                        }
                    } else {
                        // Column not found or cursor invalid
                        Err(SqawkError::VmError(format!("Column {} not found for cursor {}", column_idx, cursor_idx)))
                    }
                } else {
                    Err(SqawkError::VmError(format!("Invalid cursor: {}", cursor_idx)))
                }
            },
            
            OpCode::Integer => {
                // Load integer constant into register
                let value = inst.p1;
                let register_idx = inst.p2 as usize;
                
                if register_idx < self.registers.len() {
                    self.registers[register_idx] = Register::Integer(value);
                    Ok(ExecuteResult::Continue)
                } else {
                    Err(SqawkError::VmError(format!("Register index out of bounds: {}", register_idx)))
                }
            },
            
            OpCode::String => {
                // Load string constant into register
                let register_idx = inst.p2 as usize;
                let string_value = inst.p4.clone().unwrap_or_default();
                
                if register_idx < self.registers.len() {
                    self.registers[register_idx] = Register::String(string_value);
                    Ok(ExecuteResult::Continue)
                } else {
                    Err(SqawkError::VmError(format!("Register index out of bounds: {}", register_idx)))
                }
            },
            
            OpCode::Null => {
                // Load NULL into register
                let register_idx = inst.p2 as usize;
                
                if register_idx < self.registers.len() {
                    self.registers[register_idx] = Register::Null;
                    Ok(ExecuteResult::Continue)
                } else {
                    Err(SqawkError::VmError(format!("Register index out of bounds: {}", register_idx)))
                }
            },
            
            OpCode::ResultRow => {
                // Return a result row from registers
                let start_reg = inst.p1 as usize;
                let column_count = inst.p2 as usize;
                
                // Collect values from registers
                let mut row = Vec::with_capacity(column_count);
                for i in 0..column_count {
                    let reg_idx = start_reg + i;
                    if reg_idx < self.registers.len() {
                        // Convert register to Value
                        let value = Value::from(self.registers[reg_idx].clone());
                        row.push(value);
                    } else {
                        return Err(SqawkError::VmError(format!("Register index out of bounds: {}", reg_idx)));
                    }
                }
                
                // Add the row to results
                self.results.push(row);
                
                Ok(ExecuteResult::Continue)
            },
            
            OpCode::Noop => {
                // No operation
                Ok(ExecuteResult::Continue)
            },
            
            // Note: All opcodes are handled above, so this is unreachable
            // But the compiler doesn't know that, so we keep this for safety.
            // We could add an `#[allow(unreachable_patterns)]` here instead.
            OpCode::Noop => {
                // We already handled Noop above, this is just to silence the warning
                Ok(ExecuteResult::Continue)
            }
        }
    }
    
    // Removed unused methods get_results, has_results, get_column_names, 
    // get_affected_rows, and get_modified_tables
    
    /// Create a table from the results
    pub fn create_result_table(&self) -> SqawkResult<Option<Table>> {
        if self.results.is_empty() {
            return Ok(None);
        }
        
        // Create a new result table
        let mut table = Table::new("result", Vec::new(), None);
        
        // Add columns with dummy names (since we don't have column metadata)
        let col_count = self.results[0].len();
        for i in 0..col_count {
            table.add_column(format!("col{}", i), "UNKNOWN".to_string());
        }
        
        // Add rows
        for row in &self.results {
            table.add_row(row.clone())?;
        }
        
        Ok(Some(table))
    }
}

/// Result of executing an instruction
enum ExecuteResult {
    /// Continue to next instruction
    Continue,
    /// Jump to specified address
    Jump(usize),
    /// Halt execution
    Halt,
}