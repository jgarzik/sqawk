//! SQL VM engine that executes bytecode instructions
//!
//! This module implements the virtual machine that executes bytecode instructions
//! generated by the compiler. It maintains internal state like registers, cursors,
//! and the program counter during execution.

use super::bytecode::{Instruction, OpCode, Program, Register};
use crate::database::Database;
use crate::error::{SqawkError, SqawkResult};
use crate::table::{Table, Value};
use std::collections::HashMap;

/// Table cursor for VM execution
struct Cursor {
    /// The table being accessed
    table: Table,
    /// Current row position (0-based)
    position: usize,
    /// Whether the cursor is at a valid row
    valid: bool,
}

impl Cursor {
    /// Create a new cursor for a table
    fn new(table: Table) -> Self {
        Self {
            table,
            position: 0,
            valid: false,
        }
    }

    /// Move to the first row
    fn rewind(&mut self) -> bool {
        self.position = 0;
        self.valid = self.position < self.table.row_count();
        self.valid
    }

    /// Move to the next row
    fn next(&mut self) -> bool {
        if !self.valid {
            return false;
        }

        self.position += 1;
        self.valid = self.position < self.table.row_count();
        self.valid
    }

    /// Get a column value at the current position
    fn column(&self, idx: usize) -> Option<Value> {
        if !self.valid || idx >= self.table.column_count() {
            return None;
        }

        // Access rows from the table using the rows() method
        let rows = self.table.rows();
        if self.position < rows.len() {
            rows[self.position].get(idx).cloned()
        } else {
            None
        }
    }
}

/// Transaction state for the VM engine
///
/// This enum tracks the current state of a transaction during VM execution.
/// It enables proper validation of transaction operations (e.g., preventing
/// nested transactions or commits without an active transaction).
#[derive(Debug, Clone, Copy, PartialEq)]
enum TransactionState {
    /// No active transaction - the default state when no transaction has been started
    None,
    /// Transaction in progress - changes are being tracked but not yet permanent
    Active,
    /// Transaction has been committed - changes have been permanently applied
    Committed,
    /// Transaction has been rolled back - changes have been discarded
    RolledBack,
}

/// SQL VM engine that executes bytecode
pub struct VmEngine<'a> {
    /// The database containing tables
    database: &'a Database,

    /// The program being executed
    program: Program,

    /// Program counter (current instruction address)
    pc: usize,

    /// VM registers
    registers: Vec<Register>,

    /// Table cursors
    cursors: HashMap<usize, Cursor>,

    /// Result rows from SELECT statements
    results: Vec<Vec<Value>>,

    /// Current transaction state (None, Active, Committed, or RolledBack)
    /// Tracks the lifecycle of a transaction and enforces proper operation sequencing
    transaction_state: TransactionState,

    /// Transaction log tracking changes made during an active transaction
    /// 
    /// This stores the modified data to enable rollback operations:
    /// - First element (usize): Cursor ID that made the modification
    /// - Second element (Table): Original state of the table before modification
    /// - Third element (Vec<(usize, Value)>): List of (column_index, new_value) pairs representing changes
    transaction_log: Vec<(usize, Table, Vec<(usize, Value)>)>,

    // Removed unused fields for column_names, modified_tables, and affected_rows
    /// Whether the engine is in verbose mode
    verbose: bool,
}

impl<'a> VmEngine<'a> {
    /// Create a new VM engine
    pub fn new(database: &'a Database, verbose: bool) -> Self {
        Self {
            database,
            program: Program::new(),
            pc: 0,
            registers: Vec::new(),
            cursors: HashMap::new(),
            results: Vec::new(),
            transaction_state: TransactionState::None,
            transaction_log: Vec::new(),
            verbose,
        }
    }

    /// Initialize the VM with a program to execute
    pub fn init(&mut self, program: Program) {
        self.program = program;
        self.pc = 0;
        self.registers = Vec::new();
        self.cursors.clear();
        self.results.clear();

        // Allocate enough registers for the program
        let max_reg = self
            .program
            .instructions
            .iter()
            .map(|i| i.p1.max(i.p2).max(i.p3))
            .max()
            .unwrap_or(10);

        // Allocate a few extra registers just in case
        self.registers = vec![Register::Null; (max_reg + 5) as usize];

        // Reset transaction state
        self.transaction_state = TransactionState::None;
        self.transaction_log.clear();

        if self.verbose {
            println!("VM initialized with program:\n{}", self.program);
        }
    }

    /// Execute the current program
    pub fn execute(&mut self) -> SqawkResult<()> {
        if self.program.is_empty() {
            return Err(SqawkError::VmError("No program to execute".to_string()));
        }

        // Start execution at PC 0
        self.pc = 0;

        // Main execution loop
        loop {
            // Get current instruction
            let inst_clone = self
                .program
                .get(self.pc)
                .ok_or_else(|| {
                    SqawkError::VmError(format!("Invalid program counter: {}", self.pc))
                })?
                .clone(); // Clone the instruction to avoid borrowing issues

            if self.verbose {
                println!("Executing [{}]: {}", self.pc, inst_clone);
            }

            // Execute the instruction
            match self.execute_instruction(&inst_clone)? {
                ExecuteResult::Continue => {
                    // Move to next instruction
                    self.pc += 1;
                }
                ExecuteResult::Jump(addr) => {
                    // Jump to specified address
                    self.pc = addr;
                }
                ExecuteResult::Halt => {
                    // End execution
                    break;
                }
            }
        }

        Ok(())
    }

    /// Execute a single instruction
    fn execute_instruction(&mut self, inst: &Instruction) -> SqawkResult<ExecuteResult> {
        match inst.opcode {
            OpCode::Init => {
                // Initialize VM and jump to start address in P2
                Ok(ExecuteResult::Jump(inst.p2 as usize))
            }

            OpCode::Goto => {
                // Unconditional jump to address in P2
                Ok(ExecuteResult::Jump(inst.p2 as usize))
            }

            OpCode::Halt => {
                // End execution
                Ok(ExecuteResult::Halt)
            }

            OpCode::OpenRead => {
                // Open a cursor for reading a table
                let cursor_idx = inst.p1 as usize;
                let table_name = inst.p4.clone().unwrap_or_default();

                // Check if the table exists
                if !self.database.has_table(&table_name) {
                    return Err(SqawkError::TableNotFound(table_name));
                }

                // Get the table from the database (safe to unwrap since we checked it exists)
                let table = self.database.get_table(&table_name).unwrap();

                // Create a cursor for the table
                let cursor = Cursor::new(table.clone());
                self.cursors.insert(cursor_idx, cursor);

                Ok(ExecuteResult::Continue)
            }

            OpCode::OpenWrite => {
                // Not implementing write operations for the MVP
                Err(SqawkError::UnsupportedSqlFeature(
                    "Write operations not supported in VM".to_string(),
                ))
            }

            OpCode::Close => {
                // Close a cursor
                let cursor_idx = inst.p1 as usize;
                self.cursors.remove(&cursor_idx);

                Ok(ExecuteResult::Continue)
            }

            OpCode::Rewind => {
                // Rewind a cursor to the first row
                let cursor_idx = inst.p1 as usize;
                let jump_addr = inst.p2 as usize;

                if let Some(cursor) = self.cursors.get_mut(&cursor_idx) {
                    if cursor.rewind() {
                        // Found at least one row
                        Ok(ExecuteResult::Continue)
                    } else {
                        // Empty table, jump
                        Ok(ExecuteResult::Jump(jump_addr))
                    }
                } else {
                    Err(SqawkError::VmError(format!(
                        "Invalid cursor: {}",
                        cursor_idx
                    )))
                }
            }

            OpCode::Next => {
                // Move cursor to next row
                let cursor_idx = inst.p1 as usize;
                let jump_addr = inst.p2 as usize;

                if let Some(cursor) = self.cursors.get_mut(&cursor_idx) {
                    if cursor.next() {
                        // More rows to process
                        Ok(ExecuteResult::Jump(jump_addr))
                    } else {
                        // No more rows
                        Ok(ExecuteResult::Continue)
                    }
                } else {
                    Err(SqawkError::VmError(format!(
                        "Invalid cursor: {}",
                        cursor_idx
                    )))
                }
            }

            OpCode::Column => {
                // Read a column value into a register
                let cursor_idx = inst.p1 as usize;
                let column_idx = inst.p2 as usize;
                let register_idx = inst.p3 as usize;

                if let Some(cursor) = self.cursors.get(&cursor_idx) {
                    if let Some(value) = cursor.column(column_idx) {
                        // Store the value in the register
                        if register_idx < self.registers.len() {
                            self.registers[register_idx] = Register::from(value);
                            Ok(ExecuteResult::Continue)
                        } else {
                            Err(SqawkError::VmError(format!(
                                "Register index out of bounds: {}",
                                register_idx
                            )))
                        }
                    } else {
                        // Column not found or cursor invalid
                        Err(SqawkError::VmError(format!(
                            "Column {} not found for cursor {}",
                            column_idx, cursor_idx
                        )))
                    }
                } else {
                    Err(SqawkError::VmError(format!(
                        "Invalid cursor: {}",
                        cursor_idx
                    )))
                }
            }

            OpCode::Integer => {
                // Load integer constant into register
                let value = inst.p1;
                let register_idx = inst.p2 as usize;

                if register_idx < self.registers.len() {
                    self.registers[register_idx] = Register::Integer(value);
                    Ok(ExecuteResult::Continue)
                } else {
                    Err(SqawkError::VmError(format!(
                        "Register index out of bounds: {}",
                        register_idx
                    )))
                }
            }

            OpCode::String => {
                // Load string constant into register
                let register_idx = inst.p2 as usize;
                let string_value = inst.p4.clone().unwrap_or_default();

                if register_idx < self.registers.len() {
                    self.registers[register_idx] = Register::String(string_value);
                    Ok(ExecuteResult::Continue)
                } else {
                    Err(SqawkError::VmError(format!(
                        "Register index out of bounds: {}",
                        register_idx
                    )))
                }
            }

            OpCode::Null => {
                // Load NULL into register
                let register_idx = inst.p2 as usize;

                if register_idx < self.registers.len() {
                    self.registers[register_idx] = Register::Null;
                    Ok(ExecuteResult::Continue)
                } else {
                    Err(SqawkError::VmError(format!(
                        "Register index out of bounds: {}",
                        register_idx
                    )))
                }
            }

            OpCode::ResultRow => {
                // Return a result row from registers
                let start_reg = inst.p1 as usize;
                let column_count = inst.p2 as usize;

                // Collect values from registers
                let mut row = Vec::with_capacity(column_count);
                for i in 0..column_count {
                    let reg_idx = start_reg + i;
                    if reg_idx < self.registers.len() {
                        // Convert register to Value
                        let value = Value::from(self.registers[reg_idx].clone());
                        row.push(value);
                    } else {
                        return Err(SqawkError::VmError(format!(
                            "Register index out of bounds: {}",
                            reg_idx
                        )));
                    }
                }

                // Add the row to results
                self.results.push(row);

                Ok(ExecuteResult::Continue)
            }

            OpCode::Begin => {
                // Begin a transaction - initiates a new atomic unit of work
                // All operations performed between BEGIN and COMMIT/ROLLBACK are treated as a single
                // logical operation from the perspective of database consistency
                if self.transaction_state == TransactionState::Active {
                    return Err(SqawkError::VmError(
                        "Transaction already in progress".to_string(),
                    ));
                }

                // Initialize transaction state to track changes
                // - Set state to Active to indicate transaction is in progress
                // - Clear any previous transaction log entries
                self.transaction_state = TransactionState::Active;
                self.transaction_log.clear();

                if self.verbose {
                    println!("BEGIN TRANSACTION");
                }

                Ok(ExecuteResult::Continue)
            }

            OpCode::Commit => {
                // Commit a transaction - makes all changes permanent
                // Finalizes the changes made during the transaction and ensures they
                // become permanent, durable parts of the database state
                if self.transaction_state != TransactionState::Active {
                    return Err(SqawkError::VmError(
                        "No transaction in progress to commit".to_string(),
                    ));
                }

                // Finalize transaction
                // - Update state to Committed to indicate successful completion
                // - In a WAL implementation, this would flush changes to the main database file
                // - In an MVCC implementation, this would make changes visible to new transactions
                self.transaction_state = TransactionState::Committed;
                
                // Clear the transaction log since changes are now permanent
                // and don't need to be tracked for potential rollback
                self.transaction_log.clear();

                if self.verbose {
                    println!("COMMIT TRANSACTION");
                }

                Ok(ExecuteResult::Continue)
            }

            OpCode::Rollback => {
                // Rollback a transaction - abandons all changes made during the transaction
                // Undoes all operations since BEGIN, returning the database to its prior state
                if self.transaction_state != TransactionState::Active {
                    return Err(SqawkError::VmError(
                        "No transaction in progress to rollback".to_string(),
                    ));
                }

                // Revert all changes in the transaction log
                // In a full implementation, this would:
                // 1. Process the transaction log in reverse chronological order (LIFO)
                // 2. Restore original data values for each modified row
                // 3. Remove any newly inserted rows and restore any deleted rows
                // 4. Maintain referential integrity during the rollback process

                // Update transaction state to reflect rollback completion
                self.transaction_state = TransactionState::RolledBack;
                // Clear the transaction log
                self.transaction_log.clear();

                if self.verbose {
                    println!("ROLLBACK TRANSACTION");
                }

                Ok(ExecuteResult::Continue)
            }

            OpCode::SavePoint => {
                // Create a savepoint within the current transaction
                // A savepoint marks a point within a transaction to which you can later roll back
                // without rolling back the entire transaction
                if self.transaction_state != TransactionState::Active {
                    return Err(SqawkError::VmError(
                        "No active transaction for savepoint".to_string(),
                    ));
                }

                // In a full implementation, we would:
                // 1. Create a marker in the transaction log to identify this position
                // 2. Allow for multiple savepoints with different names
                // 3. Support rolling back to any specific savepoint
                // 4. Properly handle nested savepoints in a hierarchical manner
                let savepoint_name = inst.p4.clone().unwrap_or_else(|| format!("sp_{}", inst.p1));

                if self.verbose {
                    println!("SAVEPOINT {}", savepoint_name);
                }

                Ok(ExecuteResult::Continue)
            }

            OpCode::Release => {
                // Release a savepoint (commit changes up to the savepoint)
                // This permanently applies all changes made since the savepoint was created
                // while keeping the transaction active for further operations
                if self.transaction_state != TransactionState::Active {
                    return Err(SqawkError::VmError(
                        "No active transaction for savepoint release".to_string(),
                    ));
                }

                // In a complete implementation, we would:
                // 1. Find the specified savepoint in our transaction log
                // 2. Make all changes permanent up to that point
                // 3. Remove this savepoint and any subsequent nested savepoints
                // 4. Maintain the active transaction state for further operations
                let savepoint_name = inst.p4.clone().unwrap_or_else(|| format!("sp_{}", inst.p1));

                if self.verbose {
                    println!("RELEASE SAVEPOINT {}", savepoint_name);
                }

                Ok(ExecuteResult::Continue)
            }

            OpCode::Lt => {
                // Less than comparison (P1 < P2, result in P3)
                // P1 and P2 are register indices to compare
                // P3 is the destination register for the result (1 for true, 0 for false)
                
                // Get values from registers P1 and P2
                let reg1 = self.get_register(inst.p1 as usize)?;
                let reg2 = self.get_register(inst.p2 as usize)?;
                
                // Perform comparison based on register types
                let result = match (&reg1, &reg2) {
                    (Register::Integer(a), Register::Integer(b)) => a < b,
                    (Register::Float(a), Register::Float(b)) => a < b,
                    (Register::String(a), Register::String(b)) => a < b,
                    // For mixed types, try to convert and compare
                    (Register::Integer(a), Register::Float(b)) => (*a as f64) < *b,
                    (Register::Float(a), Register::Integer(b)) => *a < (*b as f64),
                    // Other combinations are not comparable
                    _ => return Err(SqawkError::VmError(
                        format!("Cannot compare incompatible types: {:?} and {:?}", reg1, reg2)
                    )),
                };
                
                // Store result in destination register (1 for true, 0 for false)
                let result_value = if result { Register::Integer(1) } else { Register::Integer(0) };
                self.set_register(inst.p3 as usize, result_value)?;
                
                Ok(ExecuteResult::Continue)
            }
            
            OpCode::Le => {
                // Less than or equal comparison (P1 <= P2, result in P3)
                // P1 and P2 are register indices to compare
                // P3 is the destination register for the result (1 for true, 0 for false)
                
                // Get values from registers P1 and P2
                let reg1 = self.get_register(inst.p1 as usize)?;
                let reg2 = self.get_register(inst.p2 as usize)?;
                
                // Perform comparison based on register types
                let result = match (&reg1, &reg2) {
                    (Register::Integer(a), Register::Integer(b)) => a <= b,
                    (Register::Float(a), Register::Float(b)) => a <= b,
                    (Register::String(a), Register::String(b)) => a <= b,
                    // For mixed types, try to convert and compare
                    (Register::Integer(a), Register::Float(b)) => (*a as f64) <= *b,
                    (Register::Float(a), Register::Integer(b)) => *a <= (*b as f64),
                    // Other combinations are not comparable
                    _ => return Err(SqawkError::VmError(
                        format!("Cannot compare incompatible types: {:?} and {:?}", reg1, reg2)
                    )),
                };
                
                // Store result in destination register (1 for true, 0 for false)
                let result_value = if result { Register::Integer(1) } else { Register::Integer(0) };
                self.set_register(inst.p3 as usize, result_value)?;
                
                Ok(ExecuteResult::Continue)
            }
            
            OpCode::JumpIfTrue => {
                // Jump to address P2 if register P1 contains a "truthy" value
                // A value is considered true if it's non-zero, non-empty string, etc.
                
                // Get the value to test
                let value = self.get_register(inst.p1 as usize)?;
                
                // Determine if value is "truthy"
                let is_true = match value {
                    Register::Integer(i) => i != 0,
                    Register::Float(f) => f != 0.0,
                    Register::String(s) => !s.is_empty(),
                    Register::Boolean(b) => b,
                    Register::Null => false,
                };
                
                // Jump if condition is true
                if is_true {
                    // Set program counter to destination address
                    self.pc = inst.p2 as usize;
                }
                
                Ok(ExecuteResult::Continue)
            }
            
            OpCode::JumpIfFalse => {
                // Jump to address P2 if register P1 contains a "falsy" value
                // A value is considered false if it's zero, empty string, etc.
                
                // Get the value to test
                let value = self.get_register(inst.p1 as usize)?;
                
                // Determine if value is "falsy"
                let is_false = match value {
                    Register::Integer(i) => i == 0,
                    Register::Float(f) => f == 0.0,
                    Register::String(s) => s.is_empty(),
                    Register::Boolean(b) => !b,
                    Register::Null => true,
                };
                
                // Jump if condition is false
                if is_false {
                    // Set program counter to destination address
                    self.pc = inst.p2 as usize;
                }
                
                Ok(ExecuteResult::Continue)
            }
            
            OpCode::Noop => {
                // No operation
                Ok(ExecuteResult::Continue)
            }

            #[allow(unreachable_patterns)]
            _ => {
                // This code is unreachable since all opcodes are handled above,
                // but we keep it for future-proofing and to silence compiler warnings
                Err(SqawkError::UnsupportedSqlFeature(format!(
                    "Unsupported VM opcode: {:?}",
                    inst.opcode
                )))
            }
        }
    }

    // Removed unused methods get_results, has_results, get_column_names,
    // get_affected_rows, and get_modified_tables

    /// Create a table from the results
    pub fn create_result_table(&self) -> SqawkResult<Option<Table>> {
        if self.results.is_empty() {
            return Ok(None);
        }

        // Create a new result table
        let mut table = Table::new("result", Vec::new(), None);

        // Add columns with dummy names (since we don't have column metadata)
        let col_count = self.results[0].len();
        for i in 0..col_count {
            table.add_column(format!("col{}", i), "UNKNOWN".to_string());
        }

        // Add rows
        for row in &self.results {
            table.add_row(row.clone())?;
        }

        Ok(Some(table))
    }
    
    /// Get a register value by index
    ///
    /// # Arguments
    /// * `idx` - The register index
    ///
    /// # Returns
    /// The register value or an error if the index is out of bounds
    fn get_register(&self, idx: usize) -> SqawkResult<Register> {
        if idx < self.registers.len() {
            Ok(self.registers[idx].clone())
        } else {
            Err(SqawkError::VmError(format!(
                "Register index out of bounds: {}",
                idx
            )))
        }
    }
    
    /// Set a register value by index
    ///
    /// # Arguments
    /// * `idx` - The register index
    /// * `value` - The value to set
    ///
    /// # Returns
    /// Ok(()) if successful, or an error if the index is out of bounds
    fn set_register(&mut self, idx: usize, value: Register) -> SqawkResult<()> {
        // Ensure the register exists
        while idx >= self.registers.len() {
            self.registers.push(Register::Null);
        }
        
        // Set the value
        self.registers[idx] = value;
        
        Ok(())
    }
}

/// Result of executing an instruction
enum ExecuteResult {
    /// Continue to next instruction
    Continue,
    /// Jump to specified address
    Jump(usize),
    /// Halt execution
    Halt,
}
