//! SQL statement compiler for the VM engine
//!
//! This module is responsible for compiling SQL statements parsed by sqlparser
//! into bytecode instructions that can be executed by the SQL VM.
//! It implements a visitor pattern to walk the AST generated by sqlparser.

use std::collections::HashMap;
use sqlparser::ast::{
    Query, Select, SetExpr, Statement, TableWithJoins, ObjectName, Expr, 
    SelectItem, Value as SqlValue
};
use sqlparser::dialect::HiveDialect;
use sqlparser::parser::Parser;

use crate::error::{SqawkError, SqawkResult};
use crate::database::Database;
use crate::table::Table;
use super::bytecode::{Instruction, OpCode, Program};

/// SQL statement compiler that generates bytecode for the VM engine
pub struct SqlCompiler<'a> {
    /// The database containing tables
    database: &'a Database,
    
    /// Name mapping for tables referenced in the query
    table_map: HashMap<String, String>,
    
    /// Current bytecode program being generated
    program: Program,
    
    /// Counter for register allocation
    register_counter: i64,
    
    /// Whether to generate verbose bytecode with detailed comments
    verbose: bool,
}

impl<'a> SqlCompiler<'a> {
    /// Create a new SQL compiler
    pub fn new(database: &'a Database, verbose: bool) -> Self {
        SqlCompiler {
            database,
            table_map: HashMap::new(),
            program: Program::new(),
            register_counter: 0,
            verbose,
        }
    }
    
    /// Allocate a new register and return its index
    fn allocate_register(&mut self) -> i64 {
        let reg = self.register_counter;
        self.register_counter += 1;
        reg
    }
    
    /// Reset the register counter (used between statements)
    fn reset_registers(&mut self) {
        self.register_counter = 0;
    }
    
    /// Add a comment to the program if verbose mode is enabled
    fn add_comment(&mut self, comment: &str) {
        if self.verbose {
            let noop = Instruction::new(
                OpCode::Noop,
                0, 0, 0,
                None,
                0,
                Some(comment.to_string()),
            );
            self.program.add_instruction(noop);
        }
    }
    
    /// Compile an SQL statement into bytecode
    pub fn compile(&mut self, sql: &str) -> SqawkResult<Program> {
        // Reset state for new compilation
        self.program = Program::new();
        self.reset_registers();
        self.table_map.clear();
        
        // Parse the SQL statement
        let dialect = HiveDialect {};
        let statements = Parser::parse_sql(&dialect, sql)
            .map_err(SqawkError::SqlParseError)?;
        
        if statements.is_empty() {
            return Err(SqawkError::InvalidSqlQuery(
                "No SQL statements found".to_string(),
            ));
        }
        
        // Add initial "Init" instruction that will be filled in later
        // with the address of the main program body
        let init_addr = self.program.len();
        self.program.add_instruction(Instruction::new(
            OpCode::Init,
            0, 0, 0,
            None,
            0,
            Some("Start address will be filled in later".to_string()),
        ));
        
        // Compile each statement
        for statement in statements {
            self.compile_statement(&statement)?;
        }
        
        // Add Halt instruction at the end
        self.program.add_instruction(Instruction::new(
            OpCode::Halt,
            0, 0, 0,
            None,
            0,
            Some("End execution".to_string()),
        ));
        
        // Go back and update the Init instruction with the correct start address
        // (usually this would point to setup code like transaction start)
        let transaction_addr = init_addr + 1;
        if let Some(instruction) = self.program.instructions.get_mut(init_addr) {
            instruction.p2 = transaction_addr as i64;
            instruction.comment = Some(format!("Start at {}", transaction_addr));
        }
        
        Ok(self.program.clone())
    }
    
    /// Compile a single SQL statement
    fn compile_statement(&mut self, statement: &Statement) -> SqawkResult<()> {
        match statement {
            Statement::Query(query) => self.compile_query(query),
            _ => Err(SqawkError::UnsupportedSqlFeature(
                format!("Unsupported SQL statement type: {:?}", statement)
            )),
        }
    }
    
    /// Compile a SQL query
    fn compile_query(&mut self, query: &Query) -> SqawkResult<()> {
        match &query.body {
            SetExpr::Select(select) => self.compile_select(select),
            _ => Err(SqawkError::UnsupportedSqlFeature(
                "Only simple SELECT statements are supported".to_string()
            )),
        }
    }
    
    /// Compile a SELECT statement
    fn compile_select(&mut self, select: &Select) -> SqawkResult<()> {
        if select.from.is_empty() {
            return Err(SqawkError::InvalidSqlQuery(
                "SELECT query must have at least one table".to_string(),
            ));
        }
        
        // Currently only support simple SELECT * FROM table
        let table_with_joins = &select.from[0];
        self.compile_table_scan(table_with_joins, &select.projection)?;
        
        Ok(())
    }
    
    /// Compile a table scan for a simple SELECT
    fn compile_table_scan(&mut self, table_with_joins: &TableWithJoins, projection: &[SelectItem]) -> SqawkResult<()> {
        // Get the table name
        let table_name = match &table_with_joins.relation {
            sqlparser::ast::TableFactor::Table { name, .. } => self.get_table_name(name)?,
            _ => return Err(SqawkError::UnsupportedSqlFeature(
                "Only simple table scans are supported".to_string()
            )),
        };
        
        // Check if the table exists
        if !self.database.table_exists(&table_name) {
            return Err(SqawkError::TableNotFound(table_name));
        }
        
        let table = self.database.get_table(&table_name)
            .ok_or_else(|| SqawkError::TableNotFound(table_name.clone()))?;
        
        // Get column indices for result row based on projection
        let columns = self.resolve_projection(projection, &table)?;
        
        self.add_comment(&format!("Scanning table: {}", table_name));
        
        // Open the table for reading (cursor 0)
        let cursor_idx = 0;
        let table_id = self.database.get_table_id(&table_name).unwrap_or(0) as i64;
        
        self.program.add_instruction(Instruction::new(
            OpCode::OpenRead,
            cursor_idx as i64,
            table_id,
            0,
            Some(table_name.clone()),
            0,
            Some(format!("Open table {} for reading", table_name)),
        ));
        
        // Set up the loop to scan the table
        self.program.add_instruction(Instruction::new(
            OpCode::Rewind,
            cursor_idx as i64,
            (self.program.len() + 4) as i64, // Jump past the loop if empty
            0,
            None,
            0,
            Some("Position cursor at first row"),
        ));
        
        // Loop body start address
        let loop_addr = self.program.len();
        
        // Load each column value into registers
        let mut result_regs = Vec::new();
        for (i, col_idx) in columns.iter().enumerate() {
            let value_reg = self.allocate_register();
            result_regs.push(value_reg);
            
            self.program.add_instruction(Instruction::new(
                OpCode::Column,
                cursor_idx as i64,
                *col_idx as i64,
                value_reg,
                None,
                0,
                Some(format!("r[{}] = column {} value", value_reg, col_idx)),
            ));
        }
        
        // Output the result row
        self.program.add_instruction(Instruction::new(
            OpCode::ResultRow,
            result_regs[0],  // First register in result
            result_regs.len() as i64, // Number of columns
            0,
            None,
            0,
            Some("Output result row"),
        ));
        
        // Move to next row and continue loop
        self.program.add_instruction(Instruction::new(
            OpCode::Next,
            cursor_idx as i64,
            loop_addr as i64,  // Jump back to start of loop for next row
            0,
            None,
            0,
            Some("Move to next row or exit loop"),
        ));
        
        // Close the table cursor
        self.program.add_instruction(Instruction::new(
            OpCode::Close,
            cursor_idx as i64,
            0,
            0,
            None,
            0,
            Some("Close cursor"),
        ));
        
        Ok(())
    }
    
    /// Get a normalized table name from an ObjectName
    fn get_table_name(&self, name: &ObjectName) -> SqawkResult<String> {
        if name.0.is_empty() {
            return Err(SqawkError::InvalidSqlQuery("Empty table name".to_string()));
        }
        
        // Use the last part of the object name as the table name
        // (schemas and catalogs are ignored for now)
        Ok(name.0.last().unwrap().value.clone())
    }
    
    /// Resolve projection items to column indices
    fn resolve_projection(&self, projection: &[SelectItem], table: &Table) -> SqawkResult<Vec<usize>> {
        // Check if we have a SELECT *
        let is_select_star = projection.iter().any(|item| {
            matches!(item, SelectItem::Wildcard(_))
        });
        
        if is_select_star {
            // For SELECT *, include all columns in their original order
            let column_count = table.column_count();
            Ok((0..column_count).collect())
        } else {
            Err(SqawkError::UnsupportedSqlFeature(
                "Only SELECT * is supported for now".to_string()
            ))
        }
    }
}