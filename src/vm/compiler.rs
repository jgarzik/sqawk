//! SQL statement compiler for the VM engine
//!
//! This module is responsible for compiling SQL statements parsed by sqlparser
//! into bytecode instructions that can be executed by the SQL VM.
//! It implements a visitor pattern to walk the AST generated by sqlparser.

use std::collections::HashMap;
use sqlparser::ast::{
    Query, Select, SetExpr, Statement, TableWithJoins, ObjectName,
    SelectItem
};
use sqlparser::dialect::HiveDialect;
use sqlparser::parser::Parser;

use crate::error::{SqawkError, SqawkResult};
use crate::database::Database;
use crate::table::Table;
use super::bytecode::{Instruction, OpCode, Program};

/// SQL statement compiler that generates bytecode for the VM engine
pub struct SqlCompiler<'a> {
    /// The database containing tables
    database: &'a Database,
    
    /// Name mapping for tables referenced in the query
    table_map: HashMap<String, String>,
    
    /// Current bytecode program being generated
    program: Program,
    
    /// Counter for register allocation
    register_counter: i64,
    
    /// Whether to generate verbose bytecode with detailed comments
    verbose: bool,
}

impl<'a> SqlCompiler<'a> {
    /// Create a new SQL compiler
    pub fn new(database: &'a Database, verbose: bool) -> Self {
        SqlCompiler {
            database,
            table_map: HashMap::new(),
            program: Program::new(),
            register_counter: 0,
            verbose,
        }
    }
    
    /// Allocate a new register and return its index
    fn allocate_register(&mut self) -> i64 {
        let reg = self.register_counter;
        self.register_counter += 1;
        reg
    }
    
    /// Reset the register counter (used between statements)
    fn reset_registers(&mut self) {
        self.register_counter = 0;
    }
    
    // Removed unused add_halt method
    
    /// Add a comment to the program if verbose mode is enabled
    fn add_comment(&mut self, comment: &str) {
        if self.verbose {
            let noop = Instruction::new(
                OpCode::Noop,
                0, 0, 0,
                None,
                0,
                Some(comment.to_string()),
            );
            self.program.add_instruction(noop);
        }
    }
    
    // Method compile_query_direct removed - will be reimplemented when we update to a newer sqlparser version
    // TODO: Add direct query compilation support

    /// Compile an SQL string into bytecode
    pub fn compile(&mut self, sql: &str) -> SqawkResult<Program> {
        // Reset state for new compilation
        self.program = Program::new();
        self.reset_registers();
        self.table_map.clear();
        
        // Parse the SQL statement
        let dialect = HiveDialect {};
        let statements = Parser::parse_sql(&dialect, sql)
            .map_err(SqawkError::SqlParseError)?;
        
        if statements.is_empty() {
            return Err(SqawkError::InvalidSqlQuery(
                "No SQL statements found".to_string(),
            ));
        }
        
        // Add initial "Init" instruction that will be filled in later
        // with the address of the main program body
        let init_addr = self.program.len();
        self.program.add_instruction(Instruction::new(
            OpCode::Init,
            0, 0, 0,
            None,
            0,
            Some("Start address will be filled in later".into()),
        ));
        
        // Compile each statement
        for statement in statements {
            self.compile_statement(&statement)?;
        }
        
        // Add Halt instruction at the end
        self.program.add_instruction(Instruction::new(
            OpCode::Halt,
            0, 0, 0,
            None,
            0,
            Some("End execution".to_string()),
        ));
        
        // Go back and update the Init instruction with the correct start address
        // (usually this would point to setup code like transaction start)
        let transaction_addr = init_addr + 1;
        if let Some(instruction) = self.program.instructions.get_mut(init_addr) {
            instruction.p2 = transaction_addr as i64;
            instruction.comment = Some(format!("Start at {}", transaction_addr));
        }
        
        Ok(self.program.clone())
    }
    
    // Removed unused compile_statement_into_program method
    
    /// Compile a single SQL statement
    fn compile_statement(&mut self, statement: &Statement) -> SqawkResult<()> {
        match statement {
            Statement::Query(query) => self.compile_query(query),
            _ => Err(SqawkError::UnsupportedSqlFeature(
                format!("Unsupported SQL statement type: {:?}", statement).into()
            )),
        }
    }
    
    /// Compile a SQL query
    fn compile_query(&mut self, query: &Query) -> SqawkResult<()> {
        match &*query.body {
            SetExpr::Select(select) => self.compile_select(select),
            _ => Err(SqawkError::UnsupportedSqlFeature(
                "Only simple SELECT statements are supported".to_string()
            )),
        }
    }
    
    /// Compile a SELECT statement
    fn compile_select(&mut self, select: &Select) -> SqawkResult<()> {
        if select.from.is_empty() {
            // This is a SELECT without a FROM clause (e.g., SELECT 1)
            self.compile_select_literal(&select.projection)?;
        } else {
            // Regular table scan with optional WHERE clause
            let table_with_joins = &select.from[0];
            
            // Get the table name for reference
            let table_name = match &table_with_joins.relation {
                sqlparser::ast::TableFactor::Table { name, .. } => self.get_table_name(name)?,
                _ => return Err(SqawkError::UnsupportedSqlFeature(
                    "Only simple table scans are supported".into()
                )),
            };
            
            // Get the referenced table
            if !self.database.has_table(&table_name) {
                return Err(SqawkError::TableNotFound(table_name));
            }
            
            let table = self.database.get_table(&table_name).unwrap();
            
            // Get column indices for result row based on projection
            let columns = self.resolve_projection(&select.projection, &table)?;
            
            // Set up bytecode generation
            self.add_comment(&format!("Scanning table: {}", table_name));
            
            // Add instruction to open the table for reading
            let cursor_idx = 0;
            // Use a simple counter for table ID (this would be more sophisticated in a real system)
            let table_id = 1i64;
            
            self.program.add_instruction(Instruction::new(
                OpCode::OpenRead,
                cursor_idx as i64,
                table_id,
                0,
                Some(table_name.clone()),
                0,
                Some(format!("Open table {} for reading", table_name)),
            ));
            
            // Store the location where we'll add the Rewind instruction
            // We'll need to update its jump target later once we know how many instructions
            // will be in the loop body
            let rewind_index = self.program.len();
            
            // Add a placeholder Rewind instruction (we'll fix the jump target later)
            self.program.add_instruction(Instruction::new(
                OpCode::Rewind,
                cursor_idx as i64,
                0, // Placeholder jump target
                0,
                None,
                0,
                Some("Position cursor at first row".to_string()),
            ));
            
            // Add instructions to read columns and apply WHERE filter (if any)
            let loop_start = self.program.len();
            
            // If there's a WHERE clause, compile it
            let where_end_jump = if let Some(where_expr) = &select.selection {
                self.compile_where_clause(where_expr, cursor_idx, &table)?
            } else {
                None
            };
            
            // Add instructions to load column values into registers
            let mut result_regs = Vec::new();
            
            for (i, (col_idx, col_name)) in columns.iter().enumerate() {
                let reg = self.allocate_register();
                result_regs.push(reg);
                
                self.program.add_instruction(Instruction::new(
                    OpCode::Column,
                    cursor_idx as i64,
                    *col_idx as i64,
                    reg,
                    None,
                    0,
                    Some(format!("r[{}]= cursor {} column {} ({})", 
                        reg, cursor_idx, col_idx, col_name)),
                ));
            }
            
            // Add ResultRow instruction to output the selected columns
            if !result_regs.is_empty() {
                self.program.add_instruction(Instruction::new(
                    OpCode::ResultRow,
                    result_regs[0],       // First register
                    result_regs.len() as i64,  // Number of columns
                    0,
                    None,
                    0,
                    Some("Output result row".to_string()),
                ));
            }
            
            // End of loop - move to the next row
            let next_index = self.program.len();
            self.program.add_instruction(Instruction::new(
                OpCode::Next,
                cursor_idx as i64,
                loop_start as i64,
                0,
                None,
                0,
                Some("Move to next row".to_string()),
            ));
            
            // Fix the jump target in the Rewind instruction to skip the loop if table is empty
            if let Some(instruction) = self.program.instructions.get_mut(rewind_index) {
                instruction.p2 = next_index as i64 + 1;
                instruction.comment = Some(format!("If empty table, jump to {}", instruction.p2));
            }
            
            // If we had a WHERE clause, fix any jump targets in it
            if let Some(where_end_idx) = where_end_jump {
                if let Some(instruction) = self.program.instructions.get_mut(where_end_idx) {
                    instruction.p2 = next_index as i64;
                    instruction.comment = Some(format!("WHERE false: jump to {}", instruction.p2));
                }
            }
        }
        
        Ok(())
    }
    
    /// Compile a WHERE clause and return the index of any instructions that need jump targets updated
    fn compile_where_clause(&mut self, expr: &sqlparser::ast::Expr, cursor_idx: usize, table: &Table) 
        -> SqawkResult<Option<usize>> {
        
        self.add_comment("Compiling WHERE clause");
        
        match expr {
            // Handle binary operations like comparisons
            sqlparser::ast::Expr::BinaryOp { left, op, right } => {
                match op {
                    // Handle comparison operators
                    sqlparser::ast::BinaryOperator::Gt |
                    sqlparser::ast::BinaryOperator::Lt |
                    sqlparser::ast::BinaryOperator::GtEq |
                    sqlparser::ast::BinaryOperator::LtEq |
                    sqlparser::ast::BinaryOperator::Eq |
                    sqlparser::ast::BinaryOperator::NotEq => {
                        self.compile_comparison_op(left, op, right, cursor_idx, table)
                    },
                    _ => Err(SqawkError::UnsupportedSqlFeature(
                        format!("Unsupported WHERE clause operator: {:?}", op)
                    )),
                }
            },
            _ => Err(SqawkError::UnsupportedSqlFeature(
                format!("Unsupported WHERE clause expression: {:?}", expr)
            )),
        }
    }
    
    /// Compile a comparison operator in a WHERE clause
    fn compile_comparison_op(
        &mut self, 
        left: &Box<sqlparser::ast::Expr>, 
        op: &sqlparser::ast::BinaryOperator,
        right: &Box<sqlparser::ast::Expr>,
        cursor_idx: usize,
        table: &Table
    ) -> SqawkResult<Option<usize>> {
        // For now, we only handle simple column-constant comparisons
        // like "age > 20" where the column is on the left and constant on the right
        
        // First, determine if left side is a column reference
        let column_info = match &**left {
            sqlparser::ast::Expr::Identifier(ident) => {
                // Get the column index in the table
                let col_name = ident.value.clone();
                if let Some(col_idx) = table.column_index(&col_name) {
                    (col_name, col_idx)
                } else {
                    return Err(SqawkError::ColumnNotFound(ident.value.clone()));
                }
            },
            _ => return Err(SqawkError::UnsupportedSqlFeature(
                "Only simple column references are supported in WHERE comparisons".to_string()
            )),
        };
        
        // Next, verify the right side is a constant
        let const_val = match &**right {
            sqlparser::ast::Expr::Value(value) => {
                match value {
                    sqlparser::ast::Value::Number(num, _) => {
                        if let Ok(int_val) = num.parse::<i64>() {
                            int_val
                        } else {
                            return Err(SqawkError::UnsupportedSqlFeature(
                                "Only integer constants are supported in WHERE comparisons".to_string()
                            ));
                        }
                    },
                    _ => return Err(SqawkError::UnsupportedSqlFeature(
                        "Only numeric constants are supported in WHERE comparisons".to_string()
                    )),
                }
            },
            _ => return Err(SqawkError::UnsupportedSqlFeature(
                "Only constant values are supported on the right side of WHERE comparisons".to_string()
            )),
        };
        
        // Now we can compile the comparison
        self.add_comment(&format!("WHERE: {} {:?} {}", column_info.0, op, const_val));
        
        // Load the column value into a register
        let column_reg = self.allocate_register();
        self.program.add_instruction(Instruction::new(
            OpCode::Column,
            cursor_idx as i64,
            column_info.1 as i64,
            column_reg,
            None,
            0,
            Some(format!("r[{}]= cursor {} column {} ({})", 
                column_reg, cursor_idx, column_info.1, column_info.0)),
        ));
        
        // Load the constant into a register
        let const_reg = self.allocate_register();
        self.program.add_instruction(Instruction::new(
            OpCode::Integer,
            const_val,
            const_reg,
            0,
            None,
            0,
            Some(format!("r[{}]={}", const_reg, const_val)),
        ));
        
        // Add the appropriate comparison instruction
        // The P2 parameter will be the jump target if the condition is false
        // We'll return the index of this instruction so the caller can fix the jump target
        let comparison_idx = self.program.len();
        
        let (opcode, reversed) = match op {
            sqlparser::ast::BinaryOperator::Gt => (OpCode::Le, false),  // Jump if NOT greater than
            sqlparser::ast::BinaryOperator::Lt => (OpCode::Ge, false),  // Jump if NOT less than
            sqlparser::ast::BinaryOperator::GtEq => (OpCode::Lt, false), // Jump if NOT greater than or equal
            sqlparser::ast::BinaryOperator::LtEq => (OpCode::Gt, false), // Jump if NOT less than or equal
            sqlparser::ast::BinaryOperator::Eq => (OpCode::Ne, false),  // Jump if NOT equal
            sqlparser::ast::BinaryOperator::NotEq => (OpCode::Eq, false), // Jump if NOT not equal
            _ => unreachable!(), // We already checked this above
        };
        
        // For reversed operands, swap the register parameters
        let (p1, p3) = if reversed {
            (const_reg, column_reg)
        } else {
            (column_reg, const_reg)
        };
        
        self.program.add_instruction(Instruction::new(
            opcode,
            p1,
            0, // Placeholder for jump target
            p3,
            None,
            0,
            Some(format!("if r[{}]{:?}r[{}] goto ?", p1, op, p3)),
        ));
        
        Ok(Some(comparison_idx))
    }
    
    /// Compile a SELECT statement with literals (e.g., SELECT 1, SELECT 'text')
    fn compile_select_literal(&mut self, projection: &[SelectItem]) -> SqawkResult<()> {
        self.add_comment("Literal value query (no table)");
        
        // For each selected literal, add an instruction to load it into a register
        let mut result_regs = Vec::new();
        
        for item in projection.iter() {
            match item {
                SelectItem::UnnamedExpr(expr) => {
                    // Compile a simple expression and store the value in a register
                    let reg = self.compile_expr(expr)?;
                    result_regs.push(reg);
                },
                SelectItem::ExprWithAlias { expr, alias } => {
                    // Same as UnnamedExpr but with an alias (column name)
                    let reg = self.compile_expr(expr)?;
                    result_regs.push(reg);
                    
                    // We don't need to do anything special with the alias for now
                    // But we could store it for the result table column names
                    if self.verbose {
                        self.add_comment(&format!("Column alias: {}", alias));
                    }
                },
                _ => {
                    return Err(SqawkError::UnsupportedSqlFeature(
                        "Only simple expressions supported in SELECT without FROM".to_string()
                    ));
                }
            }
        }
        
        // Generate the result row
        if !result_regs.is_empty() {
            // Output the result row
            self.program.add_instruction(Instruction::new(
                OpCode::ResultRow,
                result_regs[0],       // First register
                result_regs.len() as i64,  // Number of columns
                0,
                None,
                0,
                Some("Output literal result row".to_string()),
            ));
        }
        
        Ok(())
    }
    
    /// Compile an expression into bytecode and return the register containing the result
    fn compile_expr(&mut self, expr: &sqlparser::ast::Expr) -> SqawkResult<i64> {
        let result_reg = self.allocate_register();
        
        match expr {
            sqlparser::ast::Expr::Value(value) => {
                // Load the appropriate value based on type
                match value {
                    sqlparser::ast::Value::Number(num, _) => {
                        // Try to parse as integer first
                        if let Ok(int_val) = num.parse::<i64>() {
                            self.program.add_instruction(Instruction::new(
                                OpCode::Integer,
                                int_val,  // Value
                                result_reg, // Target register
                                0,
                                None,
                                0,
                                Some(format!("r[{}] = {}", result_reg, int_val)),
                            ));
                        } else {
                            // Return an error for now - we could add float support later
                            return Err(SqawkError::UnsupportedSqlFeature(
                                format!("Non-integer literals not yet supported: {}", num)
                            ));
                        }
                    },
                    sqlparser::ast::Value::SingleQuotedString(s) => {
                        self.program.add_instruction(Instruction::new(
                            OpCode::String,
                            0,
                            result_reg,
                            0,
                            Some(s.clone()),
                            0,
                            Some(format!("r[{}] = '{}'", result_reg, s)),
                        ));
                    },
                    sqlparser::ast::Value::Null => {
                        self.program.add_instruction(Instruction::new(
                            OpCode::Null,
                            0,
                            result_reg,
                            0,
                            None,
                            0,
                            Some(format!("r[{}] = NULL", result_reg)),
                        ));
                    },
                    _ => {
                        return Err(SqawkError::UnsupportedSqlFeature(
                            format!("Unsupported literal type: {:?}", value)
                        ));
                    }
                }
            },
            // Could add support for other expression types here
            _ => {
                return Err(SqawkError::UnsupportedSqlFeature(
                    format!("Unsupported expression type: {:?}", expr)
                ));
            }
        }
        
        Ok(result_reg)
    }
    
    /// Compile a table scan for a simple SELECT
    fn compile_table_scan(&mut self, table_with_joins: &TableWithJoins, projection: &[SelectItem]) -> SqawkResult<()> {
        // Get the table name
        let table_name = match &table_with_joins.relation {
            sqlparser::ast::TableFactor::Table { name, .. } => self.get_table_name(name)?,
            _ => return Err(SqawkError::UnsupportedSqlFeature(
                "Only simple table scans are supported".into()
            )),
        };
        
        // Check if the table exists by trying to get it
        if !self.database.has_table(&table_name) {
            return Err(SqawkError::TableNotFound(table_name));
        }
        
        // We know the table exists, so unwrap is safe
        let table = self.database.get_table(&table_name).unwrap();
        
        // Get column indices for result row based on projection
        let columns = self.resolve_projection(projection, &table)?;
        
        self.add_comment(&format!("Scanning table: {}", table_name));
        
        // Open the table for reading (cursor 0)
        let cursor_idx = 0;
        // Use a simple counter for now, since we don't have get_table_id
        let table_id = 1i64; // Just assign a default ID
        
        self.program.add_instruction(Instruction::new(
            OpCode::OpenRead,
            cursor_idx as i64,
            table_id,
            0,
            Some(table_name.clone()),
            0,
            Some(format!("Open table {} for reading", table_name)),
        ));
            0,
            None,
            0,
            Some("Position cursor at first row".to_string()),
        ));
        
        // Loop body start address
        let loop_addr = self.program.len();
        
        // Load each column value into registers
        let mut result_regs = Vec::new();
        for (_i, col_idx) in columns.iter().enumerate() {
            let value_reg = self.allocate_register();
            result_regs.push(value_reg);
            
            self.program.add_instruction(Instruction::new(
                OpCode::Column,
                cursor_idx as i64,
                *col_idx as i64,
                value_reg,
                None,
                0,
                Some(format!("r[{}] = column {} value", value_reg, col_idx)),
            ));
        }
        
        // Output the result row
        self.program.add_instruction(Instruction::new(
            OpCode::ResultRow,
            result_regs[0],  // First register in result
            result_regs.len() as i64, // Number of columns
            0,
            None,
            0,
            Some("Output result row".to_string()),
        ));
        
        // Move to next row and continue loop
        self.program.add_instruction(Instruction::new(
            OpCode::Next,
            cursor_idx as i64,
            loop_addr as i64,  // Jump back to start of loop for next row
            0,
            None,
            0,
            Some("Move to next row or exit loop".to_string()),
        ));
        
        // Close the table cursor
        self.program.add_instruction(Instruction::new(
            OpCode::Close,
            cursor_idx as i64,
            0,
            0,
            None,
            0,
            Some("Close cursor".to_string()),
        ));
        
        Ok(())
    }
    
    /// Get a normalized table name from an ObjectName
    fn get_table_name(&self, name: &ObjectName) -> SqawkResult<String> {
        if name.0.is_empty() {
            return Err(SqawkError::InvalidSqlQuery("Empty table name".to_string()));
        }
        
        // Use the last part of the object name as the table name
        // (schemas and catalogs are ignored for now)
        Ok(name.0.last().unwrap().value.clone())
    }
    
    /// Resolve projection items to column indices
    fn resolve_projection(&self, projection: &[SelectItem], table: &Table) -> SqawkResult<Vec<usize>> {
        // Check if we have a SELECT *
        let is_select_star = projection.iter().any(|item| {
            matches!(item, SelectItem::Wildcard(_))
        });
        
        if is_select_star {
            // For SELECT *, include all columns in their original order
            let column_count = table.column_count();
            Ok((0..column_count).collect())
        } else {
            Err(SqawkError::UnsupportedSqlFeature(
                "Only SELECT * is supported for now".into()
            ))
        }
    }
}